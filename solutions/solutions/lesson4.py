# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_lesson4.ipynb (unless otherwise specified).

__all__ = ['A', 'B', 'Transform', 'compose', 'ItemList', 'ResizeTransform', 'ImageItemList', 'group_by', 'Matcher',
           'map_group', 'SplitData']

# Cell
from solutions.lesson1 import *
from solutions.lesson2 import *
from solutions.lesson3 import *
from typing import List, Sequence, TypeVar, Generic, Callable, Tuple, Union, Optional, Set
from types import GeneratorType
from PIL import Image
import requests
import tempfile
from io import BytesIO
from pathlib import Path
import mimetypes
from collections import OrderedDict

# Cell
A = TypeVar('A')
B = TypeVar('B')

# Cell
class Transform(Generic[A,B]):
    _order = 0
    def __call__(self, x: A) -> B:
        raise NotImplementedError

# Cell
def compose(x: A, fs: Sequence[Callable[[A], A]]) -> A:
    sortd = sorted(fs, key=lambda x: getattr(x, '_order', 0))
    for f in sortd: x = f(x)
    return x

# Cell
class ItemList(ListContainer, Generic[A]):
    def __init__(self, items: List[A]):
        self.items = items

    def get(self, idx: int) -> A:
        return self.items[idx]

    def _get(self, idx, tfms: Union[Callable[[A], A], Sequence[Callable[[A],A]]]) -> A:
        if isinstance(tfms, (GeneratorType, set)):
            tfms = list(tfms)
        elif callable(tfms):
            tfms = [tfms]
        x = self.get(idx)
        return compose(x, tfms)

    def __repr__(self): return "{}:\n{} items\n{}".format(self.__class__.__name__, self.__len__(), super().__repr__())

# Cell
class ResizeTransform(Transform[Image.Image, Image.Image]):
    def __init__(self, px: Tuple[int, int]):
        self.px = px
    def __call__(self, img: Image):
        return img.resize(self.px)

# Cell
class ImageItemList(ItemList):
    def get(self, idx: int) -> Image:
        return Image.open(self.items[idx])

    @classmethod
    def from_files(cls, path: Union[Path, str], extensions=None, recurse=True):
        path = Path(path)
        return ImageItemList(get_files(path, extensions=extensions, recurse=recurse))

# Cell
def group_by(l: List[A], *preds: Predicate[A]):
    if len(preds) == 0:
        return []

    t = []
    f = []
    f_a, f_bs = preds[0], preds[1:]
    for elem in l:
        if f_a(elem):
            t.append(elem)
        else:
            f.append(elem)
    return [t, *group_by(f, *f_bs)]

# Cell
class Matcher(Generic[A]):
    """
    Initialized with a value `value` and optionally a function `f`.

    Tests equality of new values with `value`, optionally applying
    a transformation function `f` to the new values first.
    """
    def __init__(self, value: A, f: Optional[Callable[[A], A]] = None):
        self.value = value
        self.f = f or identity

    def __call__(self, other: A) -> bool:
        return self.value == self.f(other)

def map_group(l: List[A], vals: List[B], f: Callable[[A], B] = None) -> List[List[A]]:
    if f is None: f = identity
    return group_by(l, *[Matcher(v, f) for v in vals])

# Cell
class SplitData(Generic[A]):
    def __init__(self, train: ItemList[A], valid: ItemList[A], test: Optional[ItemList[A]] = None):
        self.train = train
        self.valid = valid
        self.test = test or ItemList([])

    def __repr__(self):
        main = "SplitData\nTrain:\n{}\n\nValid:\n{}".format(self.train, self.valid)
        if len(self.test) > 0:
            return main + "\n\nTest:\n{}".format(self.test)
        return main

    @classmethod
    def split_by_fn(cls, il: ItemList[A], f: Callable[[A], str], train_val='train', valid_val='valid', test_val='test'):
        il_cls = il.__class__
        train_f = lambda x: f(x) == train_val
        valid_f = lambda x: f(x) == valid_val
        test_f = lambda x: f(x) == test_val
        train, valid, test = group_by(il, train_f, valid_f, test_f)
        return cls(il_cls(train), il_cls(valid), il_cls(test))