# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_lesson4.ipynb (unless otherwise specified).

__all__ = ['A', 'B', 'Transform', 'compose', 'ItemList', 'ResizeTransform', 'ImageItemList', 'split_by', 'Matcher',
           'map_split', 'SplitData']

# Cell
from solutions.lesson1 import *
from solutions.lesson2 import *
from solutions.lesson3 import *
from typing import List, Sequence, TypeVar, Generic, Callable, Tuple, Union, Optional
from types import GeneratorType
from PIL import Image
import requests
import tempfile
from io import BytesIO

# Cell
A = TypeVar('A')
B = TypeVar('B')

# Cell
class Transform(Generic[A,B]):
    _order = 0
    def __call__(self, x: A) -> B:
        raise NotImplementedError

# Cell
def compose(x: A, fs: Sequence[Callable[[A], A]]) -> A:
    sortd = sorted(fs, key=lambda x: getattr(x, '_order', 0))
    for f in sortd: x = f(x)
    return x

# Cell
class ItemList(ListContainer, Generic[A]):
    def __init__(self, items: List[A]):
        self.items = items

    def get(self, idx: int) -> A:
        return self.items[idx]

    def _get(self, idx, tfms: Union[Callable[[A], A], Sequence[Callable[[A],A]]]) -> A:
        if isinstance(tfms, (GeneratorType, set)):
            tfms = list(tfms)
        elif callable(tfms):
            tfms = [tfms]
        x = self.get(idx)
        return compose(x, tfms)

    def __repr__(self): return "{}: {} items\n{}".format(self.__class__, self.__len__(), super().__repr__())

# Cell
class ResizeTransform(Transform[Image.Image, Image.Image]):
    def __init__(self, px: Tuple[int, int]):
        self.px = px
    def __call__(self, img: Image):
        return img.resize(self.px)

# Cell
class ImageItemList(ItemList):
    def get(self, idx: int) -> Image:
        return Image.open(self.items[idx])

# Cell
def split_by(l: List[A], *preds: Predicate[A]):
    if len(preds) == 0:
        return []

    t = []
    f = []
    f_a, f_bs = preds[0], preds[1:]
    for elem in l:
        if f_a(elem):
            t.append(elem)
        else:
            f.append(elem)
    return [t, *split_by(f, *f_bs)]

# Cell
class Matcher(Generic[A]):
    """
    Initialized with a value `value` and optionally a function `f`.

    Tests equality of new values with `value`, optionally applying
    a transformation function `f` to the new values first.
    """
    def __init__(self, value: A, f: Optional[Callable[[A], A]] = None):
        self.value = value
        self.f = f or identity

    def __call__(self, other: A) -> bool:
        return self.value == self.f(other)

def map_split(l: List[A], vals: List[B], f: Callable[[A], B] = None) -> List[List[A]]:
    if f is None: f = identity
    return split_by(l, *[Matcher(v, f) for v in vals])

# Cell
class SplitData(Generic[A]):
    def __init__(self, train: ItemList[A], valid: ItemList[A], test: Optional[ItemList[A]] = None):
        self.train = train
        self.valid = valid
        self.test = test or []

    @classmethod
    def split_by_fn(cls, il: ItemList[A], f: Callable[[A], str]): #TODO: use an enum here
        il_cls = il.__class__
        train, valid, test = map_split(il, ['train', 'valid', 'test'], f)
        return cls(il_cls(train), il_cls(valid), il_cls(test))